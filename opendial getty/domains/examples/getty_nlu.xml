<domain>
	<!-- Natural language understanding models, constituted of two models: one model to recognise
	the user dialogue act. from the utterance, and one model to update the slots in accordance with 
	this dialogue act.
	The user dialogue act associated with each utterance is represented here as a list of 
	basic acts (such as "Confirm" or "Inform(...)").  This representation allows us to 
	capture the fact that an utterance such as "Yes, 3 tickets" contains both a confirmation
	and a new information about the number of tickets. 
	-->

	<model trigger="u_u">
	  	  
		<!-- Extracts paintings based on culture  -->
		<!-- Right now, doesn't accept multiple word responses. I'll get on that eventually, I guess -->
		<!-- Opendial seems to be a bit buggy in that you can provide a hardcoded list and the flightbooking example will work, but a variable list and it'll just not work. Thus I need to create a custom function for it -->
		<rule>
			<case>
				<condition>
					<if var="current_step" value="Explain" relation="!="/>
				</condition>
				<effect prob="FuzzyMatch({u_u},{Cultures})">
					<set var="FuzzyGet" value="{u_u} # {Cultures} # SetCulture" exclusive="false"/>
					<set var="a_u" value="FuzzyGet" exclusive="false"/>
				</effect>
			</case>
		</rule>

		<!-- Extracts paintings based on artist  -->
		<rule>
			<case>
				<condition>
					<if var="current_step" value="Explain" relation="!="/>
				</condition>
				<effect prob="FuzzyMatch({u_u},{Artists})">
					<set var="FuzzyGet" value="{u_u} # {Artists} # SetArtist" exclusive="false"/>
					<set var="a_u" value="FuzzyGet" exclusive="false"/>
				</effect>
			</case>
		</rule>

		<!-- Extracts paintings based on the SIZE.  -->
		<!-- Sorry, but I think size is more interesting than medium here -->
		<!-- Sorry again, but I don't think this filter is necessary right now. Maybe if we go Culture -> Size -> Artist instead of Culture -> Artist or maybe we can do Size -> Artist or Size -> Culture etc. -->
		<rule>
			<case>
				<condition>
					<if var="Size" relation="in"
						value="[Oil, water]" /> <!-- GetMedium() -->
					<if var="u_u" relation="contains" value=" * {Size} * " />
				</condition>
				<effect>
					<set var="a_u" value="SetSize({Size})" exclusive="false"/>
				</effect>
			</case>
		</rule>
		
		<!-- Time to get the title -->
		<rule>
			<case>
				<condition>
					<if var="current_step" value="Explain" relation="!="/>
				</condition>
				<effect prob="FuzzyMatch({u_u},{Titles})">
					<set var="FuzzyGet" value="{u_u} # {Titles} # SetTitle" exclusive="false"/>
					<set var="a_u" value="FuzzyGet" exclusive="false"/>
				</effect>
			</case>
		</rule>
		
		<!-- Get information about the work -->
		<rule>
			<case>
				<condition>
					<if var="current_step" value="Explain" />
					<if var="u_u" relation="contains" value="(age|old|year|when|how long)" />
				</condition>
				<effect>
					<set var="a_u" value="Explain(Date)" />
				</effect>
			</case>
			<case>
				<condition>
					<if var="current_step" value="Explain" />
					<if var="u_u" relation="contains" value="(big|large|size|dimensions|small)" />
				</condition>
				<effect>
					<set var="a_u" value="Explain(Size)" />
				</effect>
			</case>
			<case>
				<condition>
					<if var="current_step" value="Explain" />
					<if var="u_u" relation="contains" value="(why|story|meaning|idea|motivation|reason)" />
				</condition>
				<effect>
					<set var="a_u" value="Explain(Story)" />
				</effect>
			</case>
			<case>
				<condition>
					<if var="current_step" value="Explain" />
					<if var="u_u" relation="contains" value="(medium|made on|canvas|panel|oil|painted on|paint|how * made)" />
				</condition>
				<effect>
					<set var="a_u" value="Explain(Medium)" />
				</effect>
			</case>
		</rule>

		<!-- Extracts confirmations and disconfirmations -->
		<rule>
			<case>
				<condition>
					<if var="u_u" relation="contains" value="(yes|correct|exactly|sure|right)" />
				</condition>
				<effect>
					<set var="a_u" value="Confirm" exclusive="false"/>
				</effect>
			</case>
			<case>
				<condition>
					<if var="u_u" relation="contains" value="(no|nope|wrong)" />
				</condition>
				<effect>
					<set var="a_u" value="Disconfirm" exclusive="false"/>
				</effect>
			</case>
		</rule>
		
		<!-- Go back a level/undo -->
		<rule>
			<case>
				<condition>
					<if var="u_u" relation="contains" value="(undo|back|done|never mind)" />
				</condition>
				<effect>
					<set var="a_u" value="GoBack()" />
				</effect>
			</case>
		</rule>

		<!-- Rule of lower priority that associates the dialogue act to "Other"
		    if nothing else is recognised. -->
		<rule priority="2">
			<case>
				<condition>
					<if var="u_u" relation="!=" value="None" />
				</condition>
				<effect>
					<set var="a_u" value="Other" exclusive="false"/>
				</effect>
			</case>
		</rule>

	</model>
	
	
	<model trigger="a_u">
		<!-- This model take the dialogue act from the user and uses it to fill the corresponding
	  slots (culture, artist, medium, size, etc.). -->
	  
	  
		<!-- Fills the slots in accordance with the information in the dialogue act -->
		<rule id="Slotfilling">
			<case>
				<condition>
					<if var="current_step" value="NameOfCulture" />
					<if var="a_u" relation="contains" value="SetCulture({Culture})" />
				</condition>
				<effect>
					<set var="ResolveCulture" value="{Culture}" />
				</effect>
			</case>
			<case>
				<condition>
					<if var="current_step" value="NameOfArtist" />
					<if var="a_u" relation="contains" value="SetArtist({Artist})" />
				</condition>
				<effect>
					<set var="ResolveArtist" value="{Artist}" />
				</effect>
			</case>
			<case>
				<condition>
					<if var="current_step" value="SizeOfArtwork" />
					<if var="a_u" relation="contains" value="SetSize({Size})" />
				</condition>
				<effect>
					<set var="{current_step}" value="{Size}" />
				</effect>
			</case>
			<case>
				<condition>
					<if var="current_step" value="TitleOfArtwork" />
					<if var="a_u" relation="contains" value="SetTitle({Title})" />
				</condition>
				<effect>
					<set var="ResolveTitle" value="{Title}" />
				</effect>
			</case>
		</rule>
		<rule id="Confirmation">
			<case>
				<condition>
					<if var="a_u" relation="contains" value="Confirm" />
					<if var="a_m" value="Confirm({Slot}, {Value})" />
				</condition>
				<effect>
					<set var="{Slot}Status" value="confirmed" />
					<set var="{Slot}" value="{Value}" />
					<set var="a_m" value="Ground({Slot})" />
				</effect>
			</case>
		</rule>
		<rule id="Disconfirmation">
			<case>
				<condition>
					<if var="a_u" relation="contains" value="Disconfirm" />
					<if var="a_m" value="Confirm({Slot}, {Value})" />
				</condition>
				<effect>
					<set var="{Slot}Status" value="empty" />
					<set var="{Slot}" value="None" />
					<set var="a_m" value="AskAgain" />
				</effect>
			</case>
		</rule>
		<!-- I just thought it'd be nice to separate the explaining step from the slot filling -->
		<rule id="Explanations">
			<case>
				<condition>
					<if var="a_u" relation="contains" value="Explain({Category})" />
				</condition>
				<effect>
					<set var="Lookup" value="{Category}" />
				</effect>
			</case>
		</rule>
		
		<!-- Go back action -->
		<rule id="GoBack">
			<case>
				<condition>
					<if var="a_u" relation="contains" value="GoBack" />
				</condition>
				<effect>
					<set var="GoBack" value="{current_step}" />
				</effect>
			</case>
		</rule>
		
		<!-- If we get other, let's just do AskRepeat, I guess -->
		<rule id="AskRepeat">
			<case>
				<condition>
					<if var="a_u" relation="contains" value="Other" />
				</condition>
				<effect>
					<set var="AskRepeat" value="AskRepeat" />
				</effect>
			</case>
		</rule>

	</model>
	
	</domain>

